
public class TileMap {
	// Позиция
	private double x;
	private double y;
	// Границы
	private int xmin;
	private int ymin;
	private int xmax;
	private int ymax;
	private double tween; // Для плавного перемещения камеры
	// Карта
	private int[][] map;
	private int tileSize;
	private int numRows;
	private int numCols;
	private int width;
	private int height;
	// Тайлсет
	private BufferedImage tileset;
	private int numTilesAcross;
	private Tile[][] tiles;
	// Отрисовка
	private int rowOffset;
	private int colOffset;
	private int numRowsToDraw;
	private int numColsToDraw;

	public TileMap(int tileSize) {
		this.tileSize = tileSize;
		// Определение количества строк и столбцов для отрисовки
		numRowsToDraw = GamePanel.HEIGHT / tileSize + 2;
		numColsToDraw = GamePanel.WIDTH / tileSize + 2;
		tween = 0.07; // Коэффициент плавности перемещения
	}

	// Загрузка тайлов изображений из файла
	public void loadTiles(String s) {
		try {
			tileset = ImageIO.read(getClass().getResourceAsStream(s));
			numTilesAcross = tileset.getWidth() / tileSize;
			tiles = new Tile[2][numTilesAcross]; // Создание массива тайлов

			BufferedImage subimage;
			// Загрузка изображений для каждого типа тайла
			for (int col = 0; col < numTilesAcross; col++) {
				subimage = tileset.getSubimage(col * tileSize, 0, tileSize, tileSize);
				tiles[0][col] = new Tile(subimage, Tile.NORMAL);
				subimage = tileset.getSubimage(col * tileSize, tileSize, tileSize, tileSize);
				tiles[1][col] = new Tile(subimage, Tile.BLOCKED);
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	// Загрузка карты из файла
	public void loadMap(String s) {
		try {
			InputStream in = getClass().getResourceAsStream(s);
			BufferedReader br = new BufferedReader(new InputStreamReader(in));
			// Чтение размеров карты
			numCols = Integer.parseInt(br.readLine());
			numRows = Integer.parseInt(br.readLine());
			map = new int[numRows][numCols];
			width = numCols * tileSize;
			height = numRows * tileSize;
			// Установка границ карты
			xmin = GamePanel.WIDTH - width;
			xmax = 0;
			ymin = GamePanel.HEIGHT - height;
			ymax = 0;
			String delims = "\\s+"; // Разделитель между значениями в строке
			// Загрузка данных карты
			for (int row = 0; row < numRows; row++) {
				String line = br.readLine();
				String[] tokens = line.split(delims);
				for (int col = 0; col < numCols; col++) {
					map[row][col] = Integer.parseInt(tokens[col]);
				}
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	// Получение размера тайла
	public int getTileSize() {
		return tileSize;
	}

	// Получение текущей позиции X
	public double getx() {
		return x;
	}

	// Получение текущей позиции Y
	public double gety() {
		return y;
	}

	// Получение ширины карты
	public int getWidth() {
		return width;
	}

	// Получение высоты карты
	public int getHeight() {
		return height;
	}

	// Получение типа тайла по указанным координатам
	public int getType(int row, int col) {
		int rc = map[row][col];
		int r = rc / numTilesAcross;
		int c = rc % numTilesAcross;
		return tiles[r][c].getType();
	}

	// Установка коэффициента плавного перемещения
	public void setTween(double d) {
		tween = d;
	}

	// Установка позиции карты
	public void setPosition(double x, double y) {
		// Плавное перемещение камеры
		this.x += (x - this.x) * tween;
		this.y += (y - this.y) * tween;
		fixBounds(); // Корректировка границ отображения карты
		colOffset = (int) -this.x / tileSize;
		rowOffset = (int) -this.y / tileSize;
	}

	// Корректировка границ отображения карты
	private void fixBounds() {
		if (x < xmin) x = xmin;
		if (y < ymin) y = ymin;
		if (x > xmax) x = xmax;
		if (y > ymax) y = ymax;
	}

	// Отрисовка карты
	public void draw(Graphics2D g) {
		for (int row = rowOffset; row < rowOffset + numRowsToDraw; row++) {
			if (row >= numRows) break;
			for (int col = colOffset; col < colOffset + numColsToDraw; col++) {
				if (col >= numCols) break;
				if (map[row][col] == 0) continue;
				int rc = map[row][col];
				int r = rc / numTilesAcross;
				int c = rc % numTilesAcross;
				g.drawImage(tiles[r][c].getImage(), (int) x + col * tileSize, (int) y + row * tileSize, null);
			}
		}
	}
}

public class Tile {
	private BufferedImage image; // Изображение тайла
	private int type; // Тип тайла

	// Виды тайлов
	public static final int NORMAL = 0; // Обычный тайл
	public static final int BLOCKED = 1; // Заблокированный тайл

	// Конструктор
	public Tile(BufferedImage image, int type) {
		this.image = image; // Устанавливаем изображение тайла
		this.type = type; // Устанавливаем тип тайла
	}

	// Метод получения изображения тайла
	public BufferedImage getImage() {
		return image;
	}

	// Метод получения типа тайла
	public int getType() {
		return type;
	}
}
public class Tile {
	private BufferedImage image; // Изображение тайла
	private int type; // Тип тайла

	// Виды тайлов
	public static final int NORMAL = 0; // Обычный тайл
	public static final int BLOCKED = 1; // Заблокированный тайл

	// Конструктор
	public Tile(BufferedImage image, int type) {
		this.image = image; // Устанавливаем изображение тайла
		this.type = type; // Устанавливаем тип тайла
	}

	// Метод получения изображения тайла
	public BufferedImage getImage() {
		return image;
	}

	// Метод получения типа тайла
	public int getType() {
		return type;
	}
}
public class Tile {
	private BufferedImage image; // Изображение тайла
	private int type; // Тип тайла

	// Виды тайлов
	public static final int NORMAL = 0; // Обычный тайл
	public static final int BLOCKED = 1; // Заблокированный тайл

	// Конструктор
	public Tile(BufferedImage image, int type) {
		this.image = image; // Устанавливаем изображение тайла
		this.type = type; // Устанавливаем тип тайла
	}

	// Метод получения изображения тайла
	public BufferedImage getImage() {
		return image;
	}

	// Метод получения типа тайла
	public int getType() {
		return type;
	}
}
public class Game {
	public static void main(String[] args) {
		// Создаем новое окно JFrame с названием "Dragon Tale"
		JFrame window = new JFrame("Dragon Tale");
		// Устанавливаем содержимое окна на экземпляр GamePanel
		window.setContentPane(new GamePanel());
		// Устанавливаем операцию закрытия окна по умолчанию, чтобы при закрытии приложение завершалось
		window.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		// Запрещаем изменение размеров окна
		window.setResizable(false);
		// Автоматически подстраиваем размеры окна под его содержимое
		window.pack();
		// Делаем окно видимым
		window.setVisible(true);
	}
}
public class MenuState extends GameState {
	private Background bg; // Фон меню
	private int currentChoice = 0; // Текущий выбор
	private String[] options = { // Варианты меню
			"Start",
			"Help",
			"Quit"
	};
	private Color titleColor; // Цвет заголовка
	private Font titleFont; // Шрифт заголовка
	private Font font; // Шрифт текста

	// Конструктор
	public MenuState(GameStateManager gsm) {
		this.gsm = gsm; // Устанавливаем менеджер состояний
		try {
			// Загрузка фона
			bg = new Background("/Backgrounds/menubg.gif", 1);
			bg.setVector(-0.1, 0); // Установка скорости движения фона

			// Установка цвета и шрифта заголовка
			titleColor = new Color(128, 0, 0);
			titleFont = new Font("Century Gothic", Font.PLAIN, 28);

			// Установка шрифта текста
			font = new Font("Arial", Font.PLAIN, 12);
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	// Инициализация состояния
	public void init() {}

	// Обновление состояния
	public void update() {
		bg.update(); // Обновление фона
	}

	// Отрисовка состояния
	public void draw(Graphics2D g) {
		// Отрисовка фона
		bg.draw(g);

		// Отрисовка заголовка
		g.setColor(titleColor);
		g.setFont(titleFont);
		g.drawString("Dragon Tale", 80, 70);

		// Отрисовка вариантов меню
		g.setFont(font);
		for (int i = 0; i < options.length; i++) {
			if (i == currentChoice) {
				g.setColor(Color.BLACK);
			} else {
				g.setColor(Color.RED);
			}
			g.drawString(options[i], 145, 140 + i * 15);
		}
	}

	// Метод выбора варианта меню
	private void select() {
		// Обработка выбора
		if (currentChoice == 0) {
			gsm.setState(GameStateManager.LEVEL1STATE); // Переход к игровому уровню
		}
		if (currentChoice == 1) {
			// Вывод помощи (возможно, реализуется позднее)
		}
		if (currentChoice == 2) {
			System.exit(0); // Завершение приложения
		}
	}

	// Обработка нажатия клавиш
	public void keyPressed(int k) {
		// Обработка нажатия клавиш для перемещения по меню и выбора пункта
		if (k == KeyEvent.VK_ENTER) {
			select(); // Вызов метода выбора
		}
		if (k == KeyEvent.VK_UP) {
			currentChoice--; // Перемещение вверх
			if (currentChoice == -1) {
				currentChoice = options.length - 1; // Циклическое перемещение вверх
			}
		}
		if (k == KeyEvent.VK_DOWN) {
			currentChoice++; // Перемещение вниз
			if (currentChoice == options.length) {
				currentChoice = 0; // Циклическое перемещение вниз
			}
		}
	}

	// Обработка отпускания клавиш (в данном состоянии не используется)
	public void keyReleased(int k) {}
}
public class Level1State extends GameState {
	private TileMap tileMap; // Карта уровня
	private Background bg; // Фон
	private Player player; // Игрок
	private ArrayList<Enemy> enemies; // Список врагов
	private ArrayList<Explosion> explosions; // Список взрывов
	private HUD hud; // Интерфейс игрока
	private AudioPlayer bgMusic; // Фоновая музыка

	// Конструктор, принимающий менеджер состояний
	public Level1State(GameStateManager gsm) {
		this.gsm = gsm;
		init(); // Инициализация состояния
	}

	// Метод инициализации состояния
	public void init() {
		// Создание карты
		tileMap = new TileMap(30);
		tileMap.loadTiles("/Tilesets/grasstileset.gif");
		tileMap.loadMap("/Maps/level1-1.map");
		tileMap.setPosition(0, 0);
		tileMap.setTween(1);

		// Создание фона
		bg = new Background("/Backgrounds/grassbg1.gif", 0.1);

		// Создание игрока
		player = new Player(tileMap);
		player.setPosition(100, 100);

		// Создание врагов
		populateEnemies();

		// Создание списка взрывов
		explosions = new ArrayList<Explosion>();

		// Создание интерфейса игрока
		hud = new HUD(player);

		// Воспроизведение фоновой музыки
		bgMusic = new AudioPlayer("/Music/level1-1.mp3");
		bgMusic.play();
	}

	// Метод для создания врагов на карте
	private void populateEnemies() {
		enemies = new ArrayList<Enemy>();
		Slugger s;
		Point[] points = new Point[] {
				new Point(200, 100),
				new Point(860, 200),
				new Point(1525, 200),
				new Point(1680, 200),
				new Point(1800, 200)
		};
		for(int i = 0; i < points.length; i++) {
			s = new Slugger(tileMap);
			s.setPosition(points[i].x, points[i].y);
			enemies.add(s);
		}
	}

	// Метод обновления состояния
	public void update() {
		// Обновление игрока
		player.update();

		// Позиционирование карты относительно игрока
		tileMap.setPosition(
				GamePanel.WIDTH / 2 - player.getx(),
				GamePanel.HEIGHT / 2 - player.gety()
		);

		// Обновление фона
		bg.setPosition(tileMap.getx(), tileMap.gety());

		// Проверка атаки игрока
		player.checkAttack(enemies);

		// Обновление всех врагов
		for(int i = 0; i < enemies.size(); i++) {
			Enemy e = enemies.get(i);
			e.update();
			if(e.isDead()) {
				enemies.remove(i);
				i--;
				explosions.add(
						new Explosion(e.getx(), e.gety()));
			}
		}

		// Обновление взрывов
		for(int i = 0; i < explosions.size(); i++) {
			explosions.get(i).update();
			if(explosions.get(i).shouldRemove()) {
				explosions.remove(i);
				i--;
			}
		}
	}

	// Метод отрисовки состояния
	public void draw(Graphics2D g) {
		// Отрисовка фона
		bg.draw(g);

		// Отрисовка карты
		tileMap.draw(g);

		// Отрисовка игрока
		player.draw(g);

		// Отрисовка врагов
		for(int i = 0; i < enemies.size(); i++) {
			enemies.get(i).draw(g);
		}

		// Отрисовка взрывов
		for(int i = 0; i < explosions.size(); i++) {
			explosions.get(i).setMapPosition(
					(int)tileMap.getx(), (int)tileMap.gety());
			explosions.get(i).draw(g);
		}

		// Отрисовка интерфейса игрока
		hud.draw(g);
	}

	// Метод обработки нажатия клавиши
	public void keyPressed(int k) {
		if(k == KeyEvent.VK_LEFT) player.setLeft(true);
		if(k == KeyEvent.VK_RIGHT) player.setRight(true);
		if(k == KeyEvent.VK_UP) player.setUp(true);
		if(k == KeyEvent.VK_DOWN) player.setDown(true);
		if(k == KeyEvent.VK_W) player.setJumping(true);
		if(k == KeyEvent.VK_E) player.setGliding(true);
		if(k == KeyEvent.VK_R) player.setScratching();
		if(k == KeyEvent.VK_F) player.setFiring();
	}

	// Метод обработки отпускания клавиши
	public void keyReleased(int k) {
		if(k == KeyEvent.VK_LEFT) player.setLeft(false);
		if(k == KeyEvent.VK_RIGHT) player.setRight(false);
		if(k == KeyEvent.VK_UP) player.setUp(false);
		if(k == KeyEvent.VK_DOWN) player.setDown(false);
		if(k == KeyEvent.VK_W) player.setJumping(false);
		if(k == KeyEvent.VK_E) player.setGliding(false);
	}
}
public class GameStateManager {
	private GameState[] gameStates; // Массив состояний игры
	private int currentState; // Текущее состояние игры
	public static final int NUMGAMESTATES = 2; // Количество состояний
	public static final int MENUSTATE = 0; // Индекс состояния меню
	public static final int LEVEL1STATE = 1; // Индекс состояния уровня

	// Конструктор
	public GameStateManager() {
		gameStates = new GameState[NUMGAMESTATES]; // Инициализация массива состояний
		currentState = MENUSTATE; // Установка начального состояния
		loadState(currentState); // Загрузка начального состояния
	}

	// Метод для загрузки состояния
	private void loadState(int state) {
		// Создание нового экземпляра состояния в зависимости от переданного индекса
		if(state == MENUSTATE)
			gameStates[state] = new MenuState(this);
		if(state == LEVEL1STATE)
			gameStates[state] = new Level1State(this);
	}

	// Метод для выгрузки состояния
	private void unloadState(int state) {
		gameStates[state] = null; // Освобождение ресурсов состояния
	}

	// Метод для установки текущего состояния
	public void setState(int state) {
		unloadState(currentState); // Выгрузка текущего состояния
		currentState = state; // Установка нового текущего состояния
		loadState(currentState); // Загрузка нового текущего состояния
	}

	// Метод для обновления текущего состояния
	public void update() {
		try {
			gameStates[currentState].update(); // Вызов метода обновления текущего состояния
		} catch(Exception e) {} // Обработка исключений
	}

	// Метод для отрисовки текущего состояния
	public void draw(java.awt.Graphics2D g) {
		try {
			gameStates[currentState].draw(g); // Вызов метода отрисовки текущего состояния
		} catch(Exception e) {} // Обработка исключений
	}

	// Метод для обработки нажатия клавиши
	public void keyPressed(int k) {
		gameStates[currentState].keyPressed(k); // Передача нажатой клавиши текущему состоянию
	}

	// Метод для обработки отпускания клавиши
	public void keyReleased(int k) {
		gameStates[currentState].keyReleased(k); // Передача отпущенной клавиши текущему состоянию
	}
}
public abstract class GameState {
	protected GameStateManager gsm; // Менеджер состояний

	// Метод инициализации состояния
	public abstract void init();

	// Метод обновления состояния
	public abstract void update();

	// Метод отрисовки состояния
	public abstract void draw(java.awt.Graphics2D g);

	// Метод обработки нажатия клавиши
	public abstract void keyPressed(int k);

	// Метод обработки отпускания клавиши
	public abstract void keyReleased(int k);
}
public class Player extends MapObject {
	// Переменные игрока
	private int health; // Здоровье
	private int maxHealth; // Максимальное здоровье
	private int fire; // Огонь (энергия)
	private int maxFire; // Максимальное значение огня
	private boolean dead; // Мертв ли игрок
	private boolean flinching; // Подвержен ли игрок "флинчу"
	private long flinchTimer; // Таймер для флинча

	// Фаерболл
	private boolean firing; // Стрельба
	private int fireCost; // Стоимость стрельбы
	private int fireBallDamage; // Урон от фаерболла
	private ArrayList<FireBall> fireBalls; // Массив с фаерболлами

	// Скретч
	private boolean scratching; // Скретч
	private int scratchDamage; // Урон от скретча
	private int scratchRange; // Радиус скретча

	// Парение
	private boolean gliding; // Парение

	// Анимации
	private ArrayList<BufferedImage[]> sprites; // Спрайты
	private final int[] numFrames = {
			2, 8, 1, 2, 4, 2, 5
	}; // Количество кадров для каждого действия

	// Действия анимации
	private static final int IDLE = 0;
	private static final int WALKING = 1;
	private static final int JUMPING = 2;
	private static final int FALLING = 3;
	private static final int GLIDING = 4;
	private static final int FIREBALL = 5;
	private static final int SCRATCHING = 6;

	// Звуковые эффекты
	private HashMap<String, AudioPlayer> sfx; // Мап для звуковых эффектов

	// Конструктор
	public Player(TileMap tm) {
		super(tm);
		width = 30;
		height = 30;
		cwidth = 20;
		cheight = 20;
		moveSpeed = 0.3;
		maxSpeed = 1.6;
		stopSpeed = 0.4;
		fallSpeed = 0.15;
		maxFallSpeed = 4.0;
		jumpStart = -4.8;
		stopJumpSpeed = 0.3;
		facingRight = true;
		health = maxHealth = 5;
		fire = maxFire = 2500;
		fireCost = 200;
		fireBallDamage = 5;
		fireBalls = new ArrayList<FireBall>();
		scratchDamage = 8;
		scratchRange = 40;

		// Загрузка спрайтов
		try {
			BufferedImage spritesheet = ImageIO.read(
					getClass().getResourceAsStream(
							"/Sprites/Player/playersprites.gif"
					)
			);
			sprites = new ArrayList<BufferedImage[]>();
			for(int i = 0; i < 7; i++) {
				BufferedImage[] bi =
						new BufferedImage[numFrames[i]];
				for(int j = 0; j < numFrames[i]; j++) {
					if(i != SCRATCHING) {
						bi[j] = spritesheet.getSubimage(
								j * width,
								i * height,
								width,
								height
						);
					} else {
						bi[j] = spritesheet.getSubimage(
								j * width * 2,
								i * height,
								width * 2,
								height
						);
					}
				}
				sprites.add(bi);
			}
		} catch(Exception e) {
			e.printStackTrace();
		}

		// Установка начальной анимации
		animation = new Animation();
		currentAction = IDLE;
		animation.setFrames(sprites.get(IDLE));
		animation.setDelay(400);

		// Инициализация звуковых эффектов
		sfx = new HashMap<String, AudioPlayer>();
		sfx.put("jump", new AudioPlayer("/Resources/SFX/jump.mp3"));
		sfx.put("scratch", new AudioPlayer("/Resources/SFX/scratch.mp3"));
	}

	// Получение здоровья
	public int getHealth() { return health; }

	// Получение максимального здоровья
	public int getMaxHealth() { return maxHealth; }

	// Получение уровня огня
	public int getFire() { return fire; }

	// Получение максимального уровня огня
	public int getMaxFire() { return maxFire; }

	// Установка состояния стрельбы
	public void setFiring() { firing = true; }

	// Установка состояния скретча
	public void setScratching() { scratching = true; }

	// Установка состояния парения
	public void setGliding(boolean b) { gliding = b; }

	// Проверка атаки
	public void checkAttack(ArrayList<Enemy> enemies) {
		// Перебор врагов
		for(int i = 0; i < enemies.size(); i++) {
			Enemy e = enemies.get(i);
			// Скретч
			if(scratching) {
				if(facingRight) {
					if(
							e.getx() > x &&
									e.getx() < x + scratchRange &&
									e.gety() > y - height / 2 &&
									e.gety() < y + height / 2
					) {
						e.hit(scratchDamage);
					}
				} else {
					if(
							e.getx() < x &&
									e.getx() > x - scratchRange &&
									e.gety() > y - height / 2 &&
									e.gety() < y + height / 2
					) {
						e.hit(scratchDamage);
					}
				}
			}
			// Фаерболлы
			for(int j = 0; j < fireBalls.size(); j++) {
				if(fireBalls.get(j).intersects(e)) {
					e.hit(fireBallDamage);
					fireBalls.get(j).setHit();
					break;
				}
			}
			// Проверка столкновения с врагом
			if(intersects(e)) {
				hit(e.getDamage());
			}
		}
	}

	// Попадание
	public void hit(int damage) {
		if(flinching) return;
		health -= damage;
		if(health < 0) health = 0;
		if(health == 0) dead = true;
		flinching = true;
		flinchTimer = System.nanoTime();
	}

	// Получение следующей позиции
	private void getNextPosition() {
		// Движение
		if(left) {
			dx -= moveSpeed;
			if(dx < -maxSpeed) {
				dx = -maxSpeed;
			}
		} else if(right) {
			dx += moveSpeed;
			if(dx > maxSpeed) {
				dx = maxSpeed;
			}
		} else {
			if(dx > 0) {
				dx -= stopSpeed;
				if(dx < 0) {
					dx = 0;
				}
			} else if(dx < 0) {
				dx += stopSpeed;
				if(dx > 0) {
					dx = 0;
				}
			}
		}

		// Невозможность движения во время атаки, кроме прыжка
		if((currentAction == SCRATCHING || currentAction == FIREBALL) &&
				!(jumping || falling)) {
			dx = 0;
		}

		// Прыжок
		if(jumping && !falling) {
			sfx.get("jump").play();
			dy = jumpStart;
			falling = true;
		}

		// Падение
		if(falling) {
			if(dy > 0 && gliding) dy += fallSpeed * 0.1;
			else dy += fallSpeed;
			if(dy > 0) jumping = false;
			if(dy < 0 && !jumping) dy += stopJumpSpeed;
			if(dy > maxFallSpeed) dy = maxFallSpeed;
		}
	}

	// Обновление
	public void update() {
		// Обновление позиции
		getNextPosition();
		checkTileMapCollision();
		setPosition(xtemp, ytemp);

		// Проверка окончания атаки
		if(currentAction == SCRATCHING) {
			if(animation.hasPlayedOnce()) scratching = false;
		}
		if(currentAction == FIREBALL) {
			if(animation.hasPlayedOnce()) firing = false;
		}

		// Атака фаерболлом
		fire += 1;
		if(fire > maxFire) fire = maxFire;
		if(firing && currentAction != FIREBALL) {
			if(fire > fireCost) {
				fire -= fireCost;
				FireBall fb = new FireBall(tileMap, facingRight);
				fb.setPosition(x, y);
				fireBalls.add(fb);
			}
		}

		// Обновление фаерболлов
		for(int i = 0; i < fireBalls.size(); i++) {
			fireBalls.get(i).update();
			if(fireBalls.get(i).shouldRemove()) {
				fireBalls.remove(i);
				i--;
			}
		}

		// Проверка завершения флинча
		if(flinching) {
			long elapsed =
					(System.nanoTime() - flinchTimer) / 1000000;
			if(elapsed > 1000) {
				flinching = false;
			}
		}

		// Установка анимации
		if(scratching) {
			if(currentAction != SCRATCHING) {
				sfx.get("scratch").play();
				currentAction = SCRATCHING;
				animation.setFrames(sprites.get(SCRATCHING));
				animation.setDelay(50);
				width = 60;
			}
		} else if(firing) {
			if(currentAction != FIREBALL) {
				currentAction = FIREBALL;
				animation.setFrames(sprites.get(FIREBALL));
				animation.setDelay(100);
				width = 30;
			}
		} else if(dy > 0) {
			if(gliding) {
				if(currentAction != GLIDING) {
					currentAction = GLIDING;
					animation.setFrames(sprites.get(GLIDING));
					animation.setDelay(100);
					width = 30;
				}
			} else if(currentAction != FALLING) {
				currentAction = FALLING;
				animation.setFrames(sprites.get(FALLING));
				animation.setDelay(100);
				width = 30;
			}
		} else if(dy < 0) {
			if(currentAction != JUMPING) {
				currentAction = JUMPING;
				animation.setFrames(sprites.get(JUMPING));
				animation.setDelay(-1);
				width = 30;
			}
		} else if(left || right) {
			if(currentAction != WALKING) {
				currentAction = WALKING;
				animation.setFrames(sprites.get(WALKING));
				animation.setDelay(40);
				width = 30;
			}
		} else {
			if(currentAction != IDLE) {
				currentAction = IDLE;
				animation.setFrames(sprites.get(IDLE));
				animation.setDelay(400);
				width = 30;
			}
		}

		// Обновление анимации
		animation.update();

		// Установка направления
		if(currentAction != SCRATCHING && currentAction != FIREBALL) {
			if(right) facingRight = true;
			if(left) facingRight = false;
		}
	}

	// Отрисовка
	public void draw(Graphics2D g) {
		setMapPosition();

		// Отрисовка фаерболлов
		for(int i = 0; i < fireBalls.size(); i++) {
			fireBalls.get(i).draw(g);
		}

		// Отрисовка игрока
		if(flinching) {
			long elapsed =
					(System.nanoTime() - flinchTimer) / 1000000;
			if(elapsed / 100 % 2 == 0) {
				return;
			}
		}
		super.draw(g);
	}
}
public abstract class MapObject {
	// Переменные для работы с тайлами
	protected TileMap tileMap; // Карта тайлов
	protected int tileSize; // Размер тайла
	protected double xmap; // Координата x на карте
	protected double ymap; // Координата y на карте

	// Переменные позиции и вектора
	protected double x; // Координата x
	protected double y; // Координата y
	protected double dx; // Вектор скорости по x
	protected double dy; // Вектор скорости по y

	// Размеры
	protected int width; // Ширина объекта
	protected int height; // Высота объекта

	// Коллизионные коробки
	protected int cwidth; // Ширина коллизионной коробки
	protected int cheight; // Высота коллизионной коробки

	// Коллизия
	protected int currRow; // Текущий ряд
	protected int currCol; // Текущий столбец
	protected double xdest; // Целевая координата x
	protected double ydest; // Целевая координата y
	protected double xtemp; // Временная координата x
	protected double ytemp; // Временная координата y
	protected boolean topLeft; // Верхний левый угол коллизионной коробки
	protected boolean topRight; // Верхний правый угол коллизионной коробки
	protected boolean bottomLeft; // Нижний левый угол коллизионной коробки
	protected boolean bottomRight; // Нижний правый угол коллизионной коробки

	// Анимация
	protected Animation animation; // Анимация
	protected int currentAction; // Текущее действие
	protected int previousAction; // Предыдущее действие
	protected boolean facingRight; // Направление вправо

	// Движение
	protected boolean left; // Движение влево
	protected boolean right; // Движение вправо
	protected boolean up; // Движение вверх
	protected boolean down; // Движение вниз
	protected boolean jumping; // Прыжок
	protected boolean falling; // Падение

	// Атрибуты движения
	protected double moveSpeed; // Скорость движения
	protected double maxSpeed; // Максимальная скорость
	protected double stopSpeed; // Скорость остановки
	protected double fallSpeed; // Скорость падения
	protected double maxFallSpeed; // Максимальная скорость падения
	protected double jumpStart; // Начальная скорость прыжка
	protected double stopJumpSpeed; // Скорость остановки прыжка

	// Конструктор
	public MapObject(TileMap tm) {
		tileMap = tm; // Установка карты тайлов
		tileSize = tm.getTileSize(); // Получение размера тайла
	}

	// Проверка пересечения с другим объектом
	public boolean intersects(MapObject o) {
		Rectangle r1 = getRectangle(); // Получение границ текущего объекта
		Rectangle r2 = o.getRectangle(); // Получение границ объекта o
		return r1.intersects(r2); // Возвращает true, если границы пересекаются
	}

	// Получение прямоугольника коллизии
	public Rectangle getRectangle() {
		return new Rectangle(
				(int)x - cwidth,
				(int)y - cheight,
				cwidth,
				cheight
		);
	}

	// Вычисление углов коллизионной коробки
	public void calculateCorners(double x, double y) {
		int leftTile = (int)(x - cwidth / 2) / tileSize;
		int rightTile = (int)(x + cwidth / 2 - 1) / tileSize;
		int topTile = (int)(y - cheight / 2) / tileSize;
		int bottomTile = (int)(y + cheight / 2 - 1) / tileSize;
		int tl = tileMap.getType(topTile, leftTile);
		int tr = tileMap.getType(topTile, rightTile);
		int bl = tileMap.getType(bottomTile, leftTile);
		int br = tileMap.getType(bottomTile, rightTile);
		topLeft = tl == Tile.BLOCKED;
		topRight = tr == Tile.BLOCKED;
		bottomLeft = bl == Tile.BLOCKED;
		bottomRight = br == Tile.BLOCKED;
	}

	// Проверка коллизии с картой тайлов
	public void checkTileMapCollision() {
		currCol = (int)x / tileSize;
		currRow = (int)y / tileSize;
		xdest = x + dx;
		ydest = y + dy;
		xtemp = x;
		ytemp = y;
		calculateCorners(x, ydest);
		if(dy < 0) {
			if(topLeft || topRight) {
				dy = 0;
				ytemp = currRow * tileSize + cheight / 2;
			}
			else {
				ytemp += dy;
			}
		}
		if(dy > 0) {
			if(bottomLeft || bottomRight) {
				dy = 0;
				falling = false;
				ytemp = (currRow + 1) * tileSize - cheight / 2;
			}
			else {
				ytemp += dy;
			}
		}

		calculateCorners(xdest, y);
		if(dx < 0) {
			if(topLeft || bottomLeft) {
				dx = 0;
				xtemp = currCol * tileSize + cwidth / 2;
			}
			else {
				xtemp += dx;
			}
		}
		if(dx > 0) {
			if(topRight || bottomRight) {
				dx = 0;
				xtemp = (currCol + 1) * tileSize - cwidth / 2;
			}
			else {
				xtemp += dx;
			}
		}
		if(!falling) {
			calculateCorners(x, ydest + 1);
			if(!bottomLeft && !bottomRight) {
				falling = true;
			}
		}
	}

	// Получение координаты x
	public int getx() { return (int)x; }

	// Получение координаты y
	public int gety() { return (int)y; }

	// Получение ширины объекта
	public int getWidth() { return width; }

	// Получение высоты объекта
	public int getHeight() { return height; }

	// Получение ширины коллизионной коробки
	public int getCWidth() { return cwidth; }

	// Получение высоты коллизионной коробки
	public int getCHeight() { return cheight; }

	// Установка позиции
	public void setPosition(double x, double y) {
		this.x = x;
		this.y = y;
	}

	// Установка вектора
	public void setVector(double dx, double dy) {
		this.dx = dx;
		this.dy = dy;
	}

	// Установка позиции карты
	public void setMapPosition() {
		xmap = tileMap.getx();
		ymap = tileMap.gety();
	}

	// Установка движения влево
	public void setLeft(boolean b) { left = b; }

	// Установка движения вправо
	public void setRight(boolean b) { right = b; }

	// Установка движения вверх
	public void setUp(boolean b) { up = b; }

	// Установка движения вниз
	public void setDown(boolean b) { down = b; }

	// Установка состояния прыжка
	public void setJumping(boolean b) { jumping = b; }

	// Проверка находится ли объект за пределами экрана
	public boolean notOnScreen() {
		return x + xmap + width < 0 ||
				x + xmap - width > GamePanel.WIDTH ||
				y + ymap + height < 0 ||
				y + ymap - height > GamePanel.HEIGHT;
	}

	// Отрисовка объекта
	public void draw(java.awt.Graphics2D g) {
		if(facingRight) {
			g.drawImage(
					animation.getImage(),
					(int)(x + xmap - width / 2),
					(int)(y + ymap - height / 2),
					null
			);
		} else {
			g.drawImage(
					animation.getImage(),
					(int)(x + xmap - width / 2 + width),
					(int)(y + ymap - height / 2),
					-width,
					height,
					null
			);
		}
	}
}
public class HUD {
	private Player player; // Ссылка на игрока
	private BufferedImage image; // Изображение для отображения HUD
	private Font font; // Шрифт для текста на HUD

	public HUD(Player p) {
		player = p; // Установка ссылки на игрока
		try {
			// Загрузка изображения HUD и создание шрифта
			image = ImageIO.read(
					getClass().getResourceAsStream(
							"/HUD/hud.gif"
					)
			);
			font = new Font("Arial", Font.PLAIN, 14);
		} catch(Exception e) {
			e.printStackTrace(); // Вывод информации об ошибке, если что-то пошло не так
		}
	}

	public void draw(Graphics2D g) {
		// Отрисовка изображения HUD
		g.drawImage(image, 0, 10, null);
		g.setFont(font); // Установка шрифта для текста
		g.setColor(Color.WHITE); // Установка белого цвета для текста
		// Отображение текущего здоровья игрока и его максимального здоровья
		g.drawString(
				player.getHealth() + "/" + player.getMaxHealth(),
				30,
				25
		);
		// Отображение текущего уровня огня игрока и его максимального уровня огня
		g.drawString(
				player.getFire() / 100 + "/" + player.getMaxFire() / 100,
				30,
				45
		);
	}
}
public class FireBall extends MapObject {
	private boolean hit; // Флаг, указывающий, попала ли огненная шаров во что-то
	private boolean remove; // Флаг, указывающий, что необходимо удалить огненный шар
	private BufferedImage[] sprites; // Спрайты для обычного состояния огненного шара
	private BufferedImage[] hitSprites; // Спрайты для состояния огненного шара при попадании

	public FireBall(TileMap tm, boolean right) {
		super(tm); // Вызов конструктора родительского класса
		facingRight = right; // Установка направления движения огненного шара
		moveSpeed = 3.8; // Установка скорости движения огненного шара
		if(right) dx = moveSpeed; // Установка скорости по оси X в зависимости от направления
		else dx = -moveSpeed;
		width = 30; // Установка ширины огненного шара
		height = 30; // Установка высоты огненного шара
		cwidth = 14; // Установка ширины столкновения огненного шара
		cheight = 14; // Установка высоты столкновения огненного шара
		// Загрузка спрайтов огненного шара
		try {
			BufferedImage spritesheet = ImageIO.read(
					getClass().getResourceAsStream(
							"/Sprites/Player/fireball.gif"
					)
			);
			sprites = new BufferedImage[4]; // Массив для спрайтов обычного состояния
			// Загрузка спрайтов для обычного состояния
			for(int i = 0; i < sprites.length; i++) {
				sprites[i] = spritesheet.getSubimage(
						i * width,
						0,
						width,
						height
				);
			}
			hitSprites = new BufferedImage[3]; // Массив для спрайтов при попадании
			// Загрузка спрайтов для состояния при попадании
			for(int i = 0; i < hitSprites.length; i++) {
				hitSprites[i] = spritesheet.getSubimage(
						i * width,
						height,
						width,
						height
				);
			}
			animation = new Animation(); // Создание анимации огненного шара
			animation.setFrames(sprites); // Установка спрайтов для анимации
			animation.setDelay(70); // Установка задержки между кадрами анимации
		} catch(Exception e) {
			e.printStackTrace(); // Вывод информации об ошибке, если что-то пошло не так
		}
	}

	public void setHit() {
		if(hit) return; // Если огненный шар уже попал, выходим из метода
		hit = true; // Устанавливаем флаг попадания
		animation.setFrames(hitSprites); // Устанавливаем спрайты для анимации при попадании
		animation.setDelay(70); // Установка задержки между кадрами анимации
		dx = 0; // Устанавливаем скорость по оси X равной 0
	}

	public boolean shouldRemove() { return remove; } // Метод, возвращающий флаг удаления огненного шара

	public void update() {
		checkTileMapCollision(); // Проверка столкновений с тайлами
		setPosition(xtemp, ytemp); // Установка новой позиции огненного шара
		if(dx == 0 && !hit) {
			setHit(); // Если огненный шар стоит на месте и еще не попал, вызываем метод попадания
		}
		animation.update(); // Обновление анимации огненного шара
		if(hit && animation.hasPlayedOnce()) {
			remove = true; // Установка флага на удаление огненного шара, если анимация при попадании проиграна один раз
		}
	}

	public void draw(Graphics2D g) {
		setMapPosition(); // Установка позиции на карте
		super.draw(g); // Вызов метода отрисовки из родительского класса
	}
}
public class Explosion {
	private int x; // Позиция по оси X
	private int y; // Позиция по оси Y
	private int xmap; // Позиция на карте по оси X
	private int ymap; // Позиция на карте по оси Y
	private int width; // Ширина взрыва
	private int height; // Высота взрыва
	private Animation animation; // Анимация взрыва
	private BufferedImage[] sprites; // Спрайты для анимации взрыва
	private boolean remove; // Флаг, указывающий на необходимость удаления взрыва

	public Explosion(int x, int y) {
		this.x = x; // Установка начальной позиции по оси X
		this.y = y; // Установка начальной позиции по оси Y
		width = 30; // Установка ширины взрыва
		height = 30; // Установка высоты взрыва
		try {
			BufferedImage spritesheet = ImageIO.read(
					getClass().getResourceAsStream(
							"/Sprites/Enemies/explosion.gif"
					)
			);
			sprites = new BufferedImage[6]; // Создание массива для спрайтов взрыва
			for(int i = 0; i < sprites.length; i++) {
				sprites[i] = spritesheet.getSubimage(
						i * width,
						0,
						width,
						height
				); // Загрузка спрайтов взрыва из спрайтшита
			}
		} catch(Exception e) {
			e.printStackTrace(); // Вывод информации об ошибке, если что-то пошло не так
		}
		animation = new Animation(); // Создание анимации взрыва
		animation.setFrames(sprites); // Установка спрайтов для анимации
		animation.setDelay(70); // Установка задержки между кадрами анимации
	}

	public void update() {
		animation.update(); // Обновление анимации взрыва
		if(animation.hasPlayedOnce()) {
			remove = true; // Установка флага на удаление взрыва, если анимация проиграна один раз
		}
	}

	public boolean shouldRemove() { return remove; } // Метод, возвращающий флаг удаления взрыва

	public void setMapPosition(int x, int y) {
		xmap = x; // Установка позиции на карте по оси X
		ymap = y; // Установка позиции на карте по оси Y
	}

	public void draw(Graphics2D g) {
		g.drawImage(
				animation.getImage(),
				x + xmap - width / 2,
				y + ymap - height / 2,
				null
		); // Отрисовка текущего кадра анимации взрыва
	}
}
package Entity;

import TileMap.TileMap;
public class Enemy extends MapObject {
	protected int health; // Здоровье врага
	protected int maxHealth; // Максимальное здоровье врага
	protected boolean dead; // Флаг, указывающий на смерть врага
	protected int damage; // Урон, который может нанести враг
	protected boolean flinching; // Флаг, указывающий на "подпрыгивание" при получении урона
	protected long flinchTimer; // Время начала "подпрыгивания" при получении урона

	public Enemy(TileMap tm) {
		super(tm); // Вызов конструктора родительского класса
	}

	public boolean isDead() { return dead; } // Метод для проверки, мертв ли враг
	public int getDamage() { return damage; } // Метод для получения урона, наносимого врагом

	public void hit(int damage) {
		if(dead || flinching) return; // Если враг мертв или уже "подпрыгивает", выход
		health -= damage; // Уменьшаем здоровье врага на значение урона
		if(health < 0) health = 0; // Если здоровье стало меньше нуля, устанавливаем его в ноль
		if(health == 0) dead = true; // Если здоровье равно нулю, враг мертв
		flinching = true; // Устанавливаем флаг "подпрыгивания"
		flinchTimer = System.nanoTime(); // Устанавливаем время начала "подпрыгивания"
	}

	public void update() {} // Обновление состояния врага
}
public class Animation {
	private BufferedImage[] frames; // Массив кадров анимации
	private int currentFrame; // Текущий кадр
	private long startTime; // Время начала анимации
	private long delay; // Задержка между кадрами
	private boolean playedOnce; // Флаг, указывающий на то, была ли анимация воспроизведена один раз

	public Animation() {
		playedOnce = false; // Инициализация флага
	}

	public void setFrames(BufferedImage[] frames) {
		this.frames = frames; // Установка массива кадров
		currentFrame = 0; // Установка начального кадра
		startTime = System.nanoTime(); // Получение текущего времени
		playedOnce = false; // Сброс флага
	}

	public void setDelay(long d) { delay = d; } // Установка задержки между кадрами
	public void setFrame(int i) { currentFrame = i; } // Установка текущего кадра

	public void update() {
		if(delay == -1) return; // Если задержка равна -1, выход

		long elapsed = (System.nanoTime() - startTime) / 1000000; // Просчитываем прошедшее время

		if(elapsed > delay) { // Если прошедшее время превышает задержку
			currentFrame++; // Переходим к следующему кадру
			startTime = System.nanoTime(); // Обновляем время начала анимации
		}

		if(currentFrame == frames.length) { // Если достигнут конец массива кадров
			currentFrame = 0; // Возвращаемся к начальному кадру
			playedOnce = true; // Устанавливаем флаг, что анимация воспроизведена один раз
		}
	}

	public int getFrame() { return currentFrame; } // Получение текущего кадра
	public BufferedImage getImage() { return frames[currentFrame]; } // Получение изображения текущего кадра
	public boolean hasPlayedOnce() { return playedOnce; } // Проверка, была ли анимация воспроизведена один раз
}
public class Slugger extends Enemy {
	private BufferedImage[] sprites; // Массив спрайтов
	public Slugger(TileMap tm) {
		super(tm); // Вызов конструктора суперкласса
		moveSpeed = 0.3; // Скорость перемещения
		maxSpeed = 0.3; // Максимальная скорость
		fallSpeed = 0.2; // Скорость падения
		maxFallSpeed = 10.0; // Максимальная скорость падения
		width = 30; // Ширина врага
		height = 30; // Высота врага
		cwidth = 20; // Ширина коллизии врага
		cheight = 20; // Высота коллизии врага
		health = maxHealth = 2; // Здоровье врага
		damage = 1; // Урон врага

		// Загрузка спрайтов
		try {
			BufferedImage spritesheet = ImageIO.read(
					getClass().getResourceAsStream(
							"/Sprites/Enemies/slugger.gif"
					)
			);
			sprites = new BufferedImage[3]; // Массив для спрайтов
			for(int i = 0; i < sprites.length; i++) {
				sprites[i] = spritesheet.getSubimage(
						i * width,
						0,
						width,
						height
				);
			}
		}
		catch(Exception e) {
			e.printStackTrace(); // Обработка исключений
		}

		animation = new Animation(); // Создание анимации
		animation.setFrames(sprites); // Установка спрайтов для анимации
		animation.setDelay(300); // Установка задержки между кадрами анимации
		right = true; // Начальное направление вправо
		facingRight = true; // Начальное направление вправо
	}

	private void getNextPosition() {
		// Движение влево
		if(left) {
			dx -= moveSpeed;
			if(dx < -maxSpeed) {
				dx = -maxSpeed;
			}
		}
		// Движение вправо
		else if(right) {
			dx += moveSpeed;
			if(dx > maxSpeed) {
				dx = maxSpeed;
			}
		}
		// Падение
		if(falling) {
			dy += fallSpeed;
		}
	}

	public void update() {
		// Обновление позиции
		getNextPosition();
		checkTileMapCollision();
		setPosition(xtemp, ytemp);

		// Проверка на нахождение в состоянии тряски
		if(flinching) {
			long elapsed = (System.nanoTime() - flinchTimer) / 1000000;
			if(elapsed > 400) {
				flinching = false;
			}
		}

		// Если враг ударился о стену, меняем направление
		if(right && dx == 0) {
			right = false;
			left = true;
			facingRight = false;
		}
		else if(left && dx == 0) {
			right = true;
			left = false;
			facingRight = true;
		}

		// Обновление анимации
		animation.update();
	}

	public void draw(Graphics2D g) {
		// Установка позиции на карте
		setMapPosition();
		// Вызов метода отрисовки суперкласса
		super.draw(g);
	}
}
package Audio;

import javax.sound.sampled.*;

// Класс для воспроизведения аудиофайлов
public class AudioPlayer {
	private Clip clip;

	// Конструктор, принимающий путь к аудиофайлу
	public AudioPlayer(String s) {
		try {
			// Загрузка аудиофайла
			AudioInputStream ais =
					AudioSystem.getAudioInputStream(
							getClass().getResourceAsStream(s)
					);
			AudioFormat baseFormat = ais.getFormat();
			AudioFormat decodeFormat = new AudioFormat(
					AudioFormat.Encoding.PCM_SIGNED,
					baseFormat.getSampleRate(),
					16,
					baseFormat.getChannels(),
					baseFormat.getChannels() * 2,
					baseFormat.getSampleRate(),
					false
			);
			AudioInputStream dais =
					AudioSystem.getAudioInputStream(
							decodeFormat, ais);
			// Открытие аудиоклипа
			clip = AudioSystem.getClip();
			clip.open(dais);
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	// Метод для воспроизведения аудио
	public void play() {
		if (clip == null) return;
		stop();
		clip.setFramePosition(0);
		clip.start();
	}

	// Метод для остановки воспроизведения аудио
	public void stop() {
		if (clip.isRunning()) clip.stop();
	}

	// Метод для закрытия аудиофайла
	public void close() {
		stop();
		clip.close();
	}
}















